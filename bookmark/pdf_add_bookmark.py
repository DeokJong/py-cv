from reportlab.lib.pagesizes import A4
from reportlab.pdfgen import canvas
from PyPDF2 import PdfReader, PdfWriter
from tqdm import tqdm

toc = [
    ("표지", 1),  # 제목 페이지
    ("저자 서문", 3),
    ("역자 서문", 17),
    ("목차", 19),
    # Part 1
    ("Part 1: 개관", 1+24, [
        ("Chapter 1: 서론", 3+24, [
            ("1.1 운영체제가 할 일", 4+24),
            ("1.2 컴퓨터 시스템의 구성", 7+24),
            ("1.3 컴퓨터 시스템 구조", 16+24),
            ("1.4 운영체제의 작동", 23+24),
            ("1.5 자원관리", 28+24),
            ("1.6 보안과 보호", 35+24),
            ("1.7 가상화", 36+24),
            ("1.8 분산시스템", 38+24),
            ("1.9 커널 자료구조", 39+24),
            ("1.10 계산환경", 43+24),
            ("1.11 무료 및 공개 소스 운영체제", 50+24),
            ("1.12 요약", 56+24),
            ("연습문제", 57+24),
            ("추가자료", 58+24)
        ]),
        ("Chapter 2: 운영체제 구조", 62+24, [
            ("2.1 운영체제 서비스", 62+24),
            ("2.2 사용자와 운영체제 인터페이스", 64+24),
            ("2.3 시스템 콜", 68+24),
            ("2.4 시스템 서비스", 82+24),
            ("2.5 링커와 로더", 84+24),
            ("2.6 응용 프로그램이 운영체제마다 다른 이유", 86+24),
            ("2.7 운영체제 설계 및 구현", 88+24),
            ("2.8 운영체제 구조", 90+24),
            ("2.9 운영체제 빌딩과 부팅", 100+24),
            ("2.10 운영체제 디버깅", 105+24),
            ("2.11 요약", 110+24),
            ("연습문제", 112+24),
            ("추가자료", 112+24)
        ]),
    ]),
    # Part 2
    ("Part 2: 프로세스 관리", 115+24, [
        ("Chapter 3: 프로세스 개념", 117+24, [
            ("3.1 프로세스 개념", 118+24),
            ("3.2 프로세스 스케줄링", 123+24),
            ("3.3 프로세스에 대한 연산", 128+24),
            ("3.4 프로세스 간 통신", 137+24),
            ("3.5 공유 메모리 시스템에서의 프로세스 간 통신", 139+24),
            ("3.6 메시지 전달 시스템에서의 프로세스 간 통신", 141+24),
            ("3.7 IPC 시스템의 사례", 146+24),
            ("3.8 클라이언트 서버 환경에서 통신", 161+24),
            ("3.9 요약", 169+24),
            ("연습문제", 171+24),
            ("추가자료", 172+24)
        ]),
        ("Chapter 4: 스레드와 병행성", 175+24, [
            ("4.1 개요", 176+24),
            ("4.2 다중 코어 프로그래밍", 178+24),
            ("4.3 다중 스레드 모델", 182+24),
            ("4.4 스레드 라이브러리", 185+24),
            ("4.5 암묵적 스레딩", 194+24),
            ("4.6 스레드와 관련된 문제들", 206+24),
            ("4.7 운영체제 사례", 213+24),
            ("4.8 요약", 215+24),
            ("연습문제", 216+24),
            ("추가자료", 217+24)
        ]),
        ("Chapter 5: CPU 스케줄링", 219+24, [
            ("5.1 기본 개념", 220+24),
            ("5.2 스케줄링 기준", 225+24),
            ("5.3 스케줄링 알고리즘", 226+24),
            ("5.4 스레드 스케줄링", 239+24),
            ("5.5 다중 처리기 스케줄링", 242+24),
            ("5.6 실시간 CPU 스케줄링", 250+24),
            ("5.7 운영체제 사례", 259+24),
            ("5.8 알고리즘의 평가", 268+24),
            ("5.9 요약", 274+24),
            ("연습문제", 276+24),
            ("추가자료", 278+24)
        ]),
    ]),
    # Part 3
    ("Part 3: 프로세스 동기화", 281+24, [
        ("Chapter 6: 동기화 도구들", 283+24, [
            ("6.1 배경", 283+24),
            ("6.2 임계 구역 문제", 286+24),
            ("6.3 Peterson의 해결안", 288+24),
            ("6.4 동기화를 위한 하드웨어 지원", 291+24),
            ("6.5 Mutex Locks", 297+24),
            ("6.6 세마포", 299+24),
            ("6.7 모니터", 303+24),
            ("6.8 라이브니스", 310+24),
            ("6.9 평가", 312+24),
            ("6.10 요약", 315+24),
            ("연습문제", 316+24),
            ("추가자료", 316+24)
        ]),
        ("Chapter 7: 동기화 예제", 319+24, [
            ("7.1 고전적 동기화 문제들", 319+24),
            ("7.2 커널 안에서의 동기화", 327+24),
            ("7.3 POSIX 동기화", 330+24),
            ("7.4 Java에서의 동기화", 334+24),
            ("7.5 대체 방안들", 342+24),
            ("7.6 요약", 345+24),
            ("연습문제", 346+24),
            ("추가자료", 346+24)
        ]),
        ("Chapter 8: 교착상태", 349+24, [
          ("8.1 시스템 모델", 350+24),
          ("8.2 다중 스레드 응용에서의 교착상태", 351+24),
          ("8.3 교착상태 특성", 353+24),
          ("8.4 교착상태 처리 방법", 358+24),
          ("8.5 교착상태 예방", 360+24),
          ("8.6 교착상태 회피", 363+24),
          ("8.7 교착상태 탐지", 371+24),
          ("8.8 교착상태로부터 회복", 376+24),
          ("8.9 요약", 378+24),
          ("연습문제", 378+24),
          ("추가자료", 380+24)
        ]),
    ]),
    # Part 4
    ("Part 4: 메모리 관리", 385+24, [
        ("Chapter 9: 메인메모리", 385+24, [
            ("8.1 배경", 385+24),
            ("8.2 연속 메모리 할당", 393+24),
            ("8.3 페이징", 397+24),
            ("8.4 페이지 테이블의 구조", 409+24),
            ("8.5 스와핑", 414+24),
            ("8.6 사례: Intel 32비트와 64비트 구조", 417+24),
            ("8.7 사례: ARM 구조", 421+24),
            ("8.8 요약", 423+24),
            ("연습문제", 424+24),
            ("추가자료", 426+24)
        ]),
        ("Chapter 10: 가상 메모리", 427+24, [
              ("10.1 배경", 428+24),
              ("10.2 요구 페이징", 431+24),
              ("10.3 쓰기 시 복사", 438+24),
              ("10.4 페이지 교체", 440+24),
              ("10.5 프레임의 할당", 454+24),
              ("10.6 스래싱", 461+24),
              ("10.7 메모리 압축", 467+24),
              ("10.8 커널 메모리의 할탕", 469+24),
              ("10.9 기타 고려 사항", 473+24),
              ("10.10 운영체제의 예", 480+24),
              ("10.11 요약", 483+24),
              ("연습문제", 484+24),
              ("추가자료", 487+24)
        ]),
    ]),
    # Part 5
    ("Part 5: 저장장치 관리", 489+24, [
        ("Chapter 11: 대용량 저장장치", 491+24, [
            ("11.1 대용량 저장장치 구조 개관", 491+24),
            ("11.2 디스크 스케줄링", 500+24),
            ("11.3 NVM 스케줄링", 504+24),
            ("11.4 오류 감지 및 수정", 505+24),
            ("11.5 저장장치 관리", 506+24),
            ("11.6 스왑 공간 관리", 511+24),
            ("11.7 저장장치 연결", 513+24),
            ("11.8 RAID 구조", 517+24),
            ("11.9 요약", 530+24),
            ("연습문제", 532+24),
            ("추가자료", 533+24)
        ]),
        ("Chapter 11: 입출력 시스템", 535+24, [
          ("12.1 개관", 535+24),
          ("12.2 입출력 하드웨어", 536+24),
          ("12.3 응용 입출력 인터페이스", 548+24),
          ("12.4 커널 입출력 서브시스템", 556+24),
          ("12.5 입출력 요구를 하드웨어 연산으로 변환", 566+24),
          ("12.6 STREAMS", 568+24),
          ("12.7 성능", 570+24),
          ("12.8 요약", 574+24),
          ("연습문제", 575+24),
          ("추가자료", 575+24)
        ])
    ]),
    # Part 6
    ("Part 6: 저장장치 관리", 579+24, [
        ("Chapter 13: 파일 시스템 인터페이스", 579+24, [
          ("13.1 파일 개념", 579+24),
          ("13.2 접근 방법", 590+24),
          ("13.3 디렉터리 구조", 593+24),
          ("13.4 보호", 603+24),
          ("13.5 메모리 사상 파일", 608+24),
          ("13.6 요약", 613+24),
          ("연습문제", 614+24),
          ("추가자료", 615+24)
        ]),
        ("Chapter 14: 파일 시스템 구현", 617+24, [
          ("14.1 파일 시스템 구조", 618+24),
          ("14.2 파일 시스템 구현", 620+24),
          ("14.3 디렉터리 구현", 623+24),
          ("14.4 할탕방법", 625+24),
          ("14.5 가용 공간의 관리", 634+24),
          ("14.6 효율과 성능", 637+24),
          ("14.7 복구", 642+24),
          ("14.8 예 :WAFL 파일 시스템", 646+24),
          ("14.9 요약", 650+24),
          ("연습문제", 651+24),
          ("추가자료", 652+24)
        ]),
        ("Chapter 15: 파일 시스템 내부구조", 655+24, [
          ("15.1 파일 시스템", 655+24),
          ("15.2 파일 시스템 마운팅", 657+24),
          ("15.3 파티션과 마운팅", 659+24),
          ("15.4 파일공유", 660+24),
          ("15.5 가상 파일 시스템", 662+24),
          ("15.6 원격 파일 시스템", 664+24),
          ("15.7 일관성의 의미", 668+24),
          ("15.8 NFS", 669+24),
          ("15.9 요약", 676+24),
          ("연습문제", 677+24),
          ("추가자료", 677+24)
        ])
    ]),
    
    # part 7
    ("Part 7: 보안와 보호", 679+24, [
      ("Chapter 16: 보안", 681+24, [
        ("16.1 보안 문제", 681+24),
        ("16.2 프로그램 위협", 685+24),
        ("16.3 시스템과 네트워크 위협", 696+24),
        ("16.4 보안 도구로서 암호 기법", 699+24),
        ("16.5 사용자 인증", 712+24),
        ("16.6 보안 방어의 구현", 717+24),
        ("16.7 예: Windows 10", 727+24),
        ("16.8 요약", 730+24),
        ("추가자료", 731+24)
      ]),
      ("Chapter 17: 보호", 733+24, [
        ("17.1 보호의 목표", 733+24),
        ("17.2 보호의 원칙", 734+24),
        ("17.3 보호 령", 735+24),
        ("17.4 보호의 영 역", 738+24),
        ("17.5 접근행렬", 742+24),
        ("17.6 접근 행렬의 구현", 746+24),
        ("17.7 접근 권한의 취소", 749+24),
        ("17.8 역할 기반 액세스 제어", 751+24),
        ("17.9 강제적 접근 제어", 752+24),
        ("17.10 자격-기반시스템", 753+24),
        ("17.11 기타보호 개선 방법", 755+24),
        ("17.12 언어 기반의 보호", 758+24),
        ("17.13 요약", 764+24),
        ("추가자료", 765+24)
      ]),
    ]),
    # part 8
    ("Part 8: 진보된 주제", 767+24, [
      ("Chapter 18: 가상머신", 769+24, [
        ("18.1 개요", 769+24),
        ("18.2 역사", 771+24),
        ("18.3 장점 및 특정", 772+24),
        ("18.4 빌딩 블록", 775+24),
        ("18.5 VM 유형 및 구현", 781+24),
        ("18.6 가상화와 운영체제 구성요소", 789+24),
        ("18.7 사례", 796+24),
        ("18.8 가상화 연구", 798+24),
        ("18.9 요약", 799+24),
        ("추가자료", 801+24)
      ]),
      ("Chapter 19: 네트워크 및 분산 시스템", 803+24, [
        ("19.1 분산 시스템의 장점", 803+24),
        ("19.2 네트워크 구조", 805+24),
        ("19.3 통신구조", 808+24),
        ("19.4 네트워크 및 분산 운영체제", 820+24),
        ("19.5 분산 시스템의 설계 문제", 824+24),
        ("19.6 분산 파일 시스템", 829+24),
        ("19.7 DFS 명병 및 투명성", 833+24),
        ("19.8 원격 파일 액세스", 836+24),
        ("19.9 분산 파일 시스템에 대한 최종 생각", 840+24),
        ("19.10 요약", 841+24),
        ("연습문제", 842+24),
        ("추가자료", 843+24)
      ])
    ]),
    # part 9
    ("Part 9: 사례 검토", 845+24, [
      ("Chapter 20: Linux 시스템", 847+24, [
        ("20.1 Linux 역사", 847+24),
        ("20.2 설계 원칙", 853+24),
        ("20.3 커널 모률", 856+24),
        ("20.4 프로세스 관리", 860+24),
        ("20.5 스케줄링", 864+24),
        ("20.6 메모리 관리", 870+24),
        ("20.7 파일 시스멈", 880+24),
        ("20.8 입/출력", 887+24),
        ("20.9 프로세스 간 통신", 890+24),
        ("20.10 네트워크 구조", 891+24),
        ("20.11 보안", 894+24),
        ("20.12 요약", 897+24),
        ("연습문제", 898+24),
        ("추가자료", 898+24)
      ]),
      ("Chapter 21: 윈도우 10", 901+24, [
        ("21.1 역사", 901+24),
        ("21.2 설계 원칙", 906+24),
        ("21.3 시스템 구성요소", 920+24),
        ("21.4 터미널 서비스와빠른샤용자교체", 960+24),
        ("21.5 파일 시스뱀", 961+24),
        ("21.6 네트워킹", 968+24),
        ("21.7 프로그래머 인터페이스", 973+24),
        ("21.8 요약", 986+24),
        ("연습문제", 987+24),
        ("추가자료", 987+24)
      ])
    ]),
    
    # 부록
    ("Part 10: 부록", 989+24, [
        ("Appendix A: 영향력 있는 운영체제", 991+24, [
          ("A.1 기능전이", 991+24),
          ("A.2 초기 시스템", 992+24),
          ("A.3 Atlas", 993+24),
          ("A.4 XDS-940", 1001+24),
          ("A.5 THE", 1002+24),
          ("A.6 RC 4000", 1002+24),
          ("A.7 CTSS", 1004+24),
          ("A.8 MULTICS", 1004+24),
          ("A.9 IBM OS/360", 1005+24),
          ("A.10 TOPS-20", 1006+24),
          ("A.ll CP/M과 MS/DOS", 1007+24),
          ("A.12 Macintosh 운영체제와 Windows", 1008+24),
          ("A.13 Mach", 1008+24),
          ("A.14 자격 기반 시스템 Hydra 및 CAP", 1010+24),
          ("A.15 기타 시스템들", 1013+24),
          ("추가자료", 1013+24)
        ]),
    ]),
    ("찾아보기", 1017+24)
]

# 북마크 추가 (트리 구조)
def add_bookmarks(writer, title, page_number=None, children=None, parent=None):
    # 현재 레벨의 북마크 추가
    if page_number is not None:
        parent = writer.add_outline_item(title, page_number - 1, parent=parent)
    
    # 하위 항목(자식)이 있으면 재귀적으로 처리
    if children:
        for child in children:
            add_bookmarks(writer, *child, parent=parent)

# TOC 처리 함수
def process_toc(toc, writer):
    # 전체 항목의 개수를 계산하기 위해, children이 있는 경우만 길이를 계산
    def count_items(toc):
        count = 0
        for part in toc:
            count += 1  # Part 항목
            if len(part) > 2 and part[2]:  # children이 있는 경우
                count += len(part[2])  # 그 하위 children의 수
                for chapter in part[2]:
                    if len(chapter) > 2 and chapter[2]:  # Chapter 하위의 children이 있는 경우
                        count += len(chapter[2])
        return count

    total_items = count_items(toc)

    # 진행 상황 표시를 위해 tqdm 적용
    with tqdm(total=total_items, desc="Adding Bookmarks", unit="item") as pbar:
        for part in toc:
            add_bookmarks(writer, *part)
            pbar.update(1)  # Part마다 1씩 증가
            if len(part) > 2 and part[2]:  # Chapter가 있을 때
                for chapter in part[2]:
                    pbar.update(1)  # Chapter마다 1씩 증가
                    if len(chapter) > 2 and chapter[2]:  # 세부 항목이 있을 때
                        pbar.update(len(chapter[2]))  # 세부 항목 수만큼 업데이트

# PDF 파일 열기
reader = PdfReader("input.pdf")
writer = PdfWriter()

page_count = len(reader.pages)

# 모든 페이지를 복사
with tqdm(total=page_count, desc="Copying Pages", unit="page") as pbar:
    for page in reader.pages:
        writer.add_page(page)
        pbar.update(1)

# TOC를 기반으로 북마크 추가
process_toc(toc, writer)

# 새로운 PDF 파일로 저장
with open("output_with_tree_bookmarks.pdf", "wb") as output_pdf:
    writer.write(output_pdf)

print("트리 형태의 목차가 추가된 PDF가 생성되었습니다.")